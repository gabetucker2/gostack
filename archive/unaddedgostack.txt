

<h1 name = "glossary">Glossary</h1>

 > [Files](#files)

 > [Preface](#preface)
 >> [Introduction](#introduction)
 >
 >> [Glossary](#glossary)
 >
 >> [File Explanations](#fileExplanations)
 >
 >> [Package Schema](#packageSchema)
 >
 >> [Conventions](#conventions)

 > [Overview](#overview)
 >> [Brief Documentation](#briefDocumentation)
 >>> [Data Structures](#dataStructuresBrief)
 >>>> [structs](#structsBrief)
 >>>
 >>>> [enums](#enumsBrief)
 >>>
 >>> [Non-Generalized Functions](#nonGeneralizedFunctionsBrief)
 >>>
 >>> [Generalized Functions](#generalizedFunctionsBrief)
 >
 >> [Exhaustive Documentation](#exhaustiveDocumentation)
 >>> [Data Structures](#dataStructures)
 >>>> [structs](#structs)
 >>>>> [Stack](#stack)
 >>>>
 >>>>> [Card](#card)
 >>>>
 >>>> [enums](#enums)
 >>>>> [RETURN](#RETURN)
 >>>>
 >>>>> [FIND](#FIND)
 >>>>
 >>>>> [REPLACE](#REPLACE)
 >>>>
 >>>>> [TYPE](#TYPE)
 >>>>
 >>>>> [ORDER](#ORDER)
 >>>>
 >>>>> [DEREFERENCE](#DEREFERENCE)
 >>>>
 >>>>> [CLONE](#CLONE)
 >>>>
 >>>>> [DEEPSEARCH](#DEEPSEARCH)
 >>>>
 >>>>> [COMPARE](#COMPARE)
 >>>>
 >>>>> [PASS](#PASS)
 >>>
 >>> [Non-Generalized Functions](#nonGeneralizedFunctions)
 >>>> [MakeCard(...)](#MakeCard)
 >>>
 >>>> [MakeStack(...)](#MakeStack)
 >>>
 >>>> [MakeStackMatrix(...)](#MakeStackMatrix)
 >>>
 >>>> [stack.StripStackMatrix(...)](#StripStackMatrix)
 >>>
 >>>> [stack.ToArray()](#ToArray)
 >>>
 >>>> [stack.ToMap()](#ToMap)
 >>>
 >>>> [stack.ToMatrix(...)](#ToMatrix)
 >>>
 >>>> [stack.IsRegular()](#IsRegular)
 >>>
 >>>> [stack.Shape()](#Shape)
 >>>
 >>>> [stack.Duplicate(...)](#Duplicate)
 >>>
 >>>> [stack.Empty()](#Empty)
 >>>
 >>>> [card.Clone(...)](#Clone)
 >>>>
 >>>> [stack.Clone(...)](#Clone)
 >>>
 >>>> [stack.Unique(...)](#Unique)
 >>>
 >>>> [card.Equals(...)](#Equals)
 >>>>
 >>>> [stack.Equals(...)](#Equals)
 >>>
 >>>> [stack.Shuffle()](#Shuffle)
 >>>
 >>>> [stack.Transpose()](#Transpose)
 >>>
 >>>> [card.Print()](#Print)
 >>>>
 >>>> [stack.Print()](#Print)
 >>>
 >>>> [stack.Lambda(...)](#Lambda)
 >>>>> [stack.LambdaThis(...)](#Lambda)
 >>>>>
 >>>>> [stack.LambdaStack(...)](#Lambda)
 >>>>>
 >>>>> [stack.LambdaCard(...)](#Lambda)
 >>>>>
 >>>>> [stack.LambdaVarAdr(...)](#Lambda)
 >>>
 >>> [Generalized Functions](#generalizedFunctions)
 >>>> [stack.Add(...)](#Add)
 >>>>
 >>>> [stack.AddMany(...)](#AddMany)
 >>>
 >>>> [stack.Move(...)](#Move)
 >>>
 >>>> [stack.Swap(...)](#Swap)
 >>>
 >>>> [stack.Has(...)](#Has)
 >>>
 >>>> [stack.Get(...)](#Get)
 >>>>
 >>>> [stack.GetMany(...)](#GetMany)
 >>>
 >>>> [stack.Replace(...)](#Replace)
 >>>>
 >>>> [stack.ReplaceMany(...)](#ReplaceMany)
 >>>
 >>>> [stack.Update(...)](#Update)
 >>>>
 >>>> [stack.UpdateMany(...)](#UpdateMany)
 >>>
 >>>> [stack.Extract(...)](#Extract)
 >>>>
 >>>> [stack.ExtractMany(...)](#ExtractMany)
 >>>
 >>>> [stack.Remove(...)](#Remove)
 >>>>
 >>>> [stack.RemoveMany(...)](#RemoveMany)
 >
 >> [Future Updates](#futureUpdates)
 >
 >> [Footer](#footer)

<h1 name = "fileExplanations">File Explanations</h1>

 > [gostack](#Files) [**.../gostack** package] any .go files that are direct children of this folder will be built to the **.../gostack** package
 >>
 >> [casetests](/casetests) [**.../gostack/casetests** package]
 >>> [CaseEnd.go](/casetests/CaseEnd.go) contains case tests for **library.go** functions
 >>
 >>> [testend.go](/casetests/testend.go) contains functions to implement **caseend.go** functions
 >>
 >>> [unaddedcases.txt](/casetests/unaddedcases.txt) is where obsolete data to be added into future case tests is stored, intended only for the developers
 >>
 >> [executive](/executive) [**main** package]
 >>> [executive.go](/executive.go) exists to call functions in this project, either for case testing or executing tutorials
 >>
 >> [images](/images)
 >>> **gostack_SmallerTransparent.png** is the banner image for this project
 >>
 >>> **packages.png** is a layout of the package dependencies/structure of this project
 >>
 >> [tutorials](/tutorials) [**.../gostack/tutorials** package]
 >>> [Bootstrap.go](/tutorials/Bootstrap.go) is a tutorial on how to implement some common functions using golang
 >>
 >>> [Introduction.go](/tutorials/Introduction.go) contains a tutorial for absolute beginners to ***gostack***
 >>
 >>> [Lambda.go](/tutorials/Lambda.go) is a tutorial on how to implement lambda functions
 >>
 >>> [Matrices.go](/tutorials/Matrices.go) is a tutorial on how to implement matrices in ***gostack***
 >>
 >>> [ObjectReference.go](/tutorials/ObjectReference.go) is a tutorial on how to use passing-by-object and -by-reference with respect to ***gostack*** functions
 >>
 >>> [race.md](/tutorials/race.md) showcases a race to complete the same set of tasks using ***classical go*** vs ***gostack***
 >>
 >>> [unaddedtutorials.txt](/tutorials/unaddedtutorials.txt) is where obsolete data to be added into future tutorials is stored, intended only for the developers
 >>
 >> [backend.go](/backend/backend.go) contains private functions to implement **Library.go**
 >>
 >> [DataStructures.go](/DataStructures.go) initializes structs and enums, as well as methods for conversion
 >>
 >> [go.mod](/go.mod) is to initialize the directories
 >>
 >> [frontend.go](/frontend.go)  contains public functions that the user will be calling
 >>
 >> [README.md](/README.md) is this file
 >>
 >> [unaddedgostack.txt](/unaddedgostack.txt) is where obsolete data to be added back into backend.go and Library.go

<h1 name = "packageSchema">Package Schema</h1>

![Packages](images/packages.png)

<h1 name = "conventions">CONVENTIONS</h1>

 <h2>General</h2>

 If depth is inputted as type{int}, then every substack and card down to that int will be considered.  If depth is inputted as type{[]int} (only allowed to be inputted this way in some functions, defined in their respective documentation), then only the levels as depth down from the top as each int will be considered.  For instance, if you wanted to test for all things in the first, second, and third layer from the outer stack, then you would do depth = 3.  If you only wanted to test the first and the third, however, then you would do depth = []int {1, 3}.

 Executing `go run executive/executive.go` in a terminal in the main directory, or executing `go run .` in the `executive` directory, will run whichever file(s) are being called by `executive.go`.

 **Generalized Functions** refer to functions that have a `findType` and `findData` parameter, meaning they perform a search through the stack for upon where to act.

 In ***gostack***, creating an array of cards is considered atrocious and immoral.  There is no functional support for passing arrays of cards as an argument.  Please only create a []\*Card array if it is a temporary variable to which you are assigning `stack.Cards`.  For instance, if you wanted to make your own `stack.Move(...)` function, you would create a temporary []\*Card variable, iteratively append that variable such that it "moves" whatever card(s) you want to move, then assign `stack.Cards` to that variable, never referencing the variable again.

 Never insert the same card twice into the same stack.  Instead, insert the same value into two different cards.  If you insert two of the same card into the same stack, then the index property will become conflated between the two cards and functions will yield bugs while iterating through stacks.

 While you are technically permitted to have a substack within a card.Key, gostack functions always assume substacks are within card.Val's.  If you choose to do this, you are on your own.

 <h2>Naming</h2>

 * "FunctionName" functions are public functions, accessible to the user
 * "functionName" functions are private functions, hidden from the user
 * "FileName" files contain at least one public function (ideally which calls all private functions within that file)/struct, accessible to the user
 * "filename" files contain all private stuff, hidden from the user

 <h2>Design-By-Contract</h2>

 We use design-by-contract principles with JDoc annotations, as instructed by OSU's CSE department (http://web.cse.ohio-state.edu/software/2221/web-sw1/extras/slides/09.Design-by-Contract.pdf).

<h1 name = "overview">OVERVIEW</h1>

<h1 name = "briefDocumentation">Brief Documentation</h1>

<h2 name = "dataStructuresBrief">Data Structures</h2>

<h3 name = "structsBrief">Structs</h3>

 > **stack** *Stack*
 >> **Cards** *[]\*Card*
 >
 >> **Size** *int*
 >
 >> **Height** *int*

 > **card** *Card*
 >> **Idx** *int*
 >
 >> **Key** *any*
 >
 >> **Val** *any*

<h3 name = "enumsBrief">Enums</h3>

 > **RETURN**
 > * _RETURN_NotationSample *type that's returned*
 > * RETURN_Idxs *stack of ints*
 > * RETURN_Keys *stack of anys*
 > * RETURN_Vals *stack of anys*
 > * RETURN_Cards *stack of Cards*

 > **FIND**
 > * _FIND_NotationSample *findData argument type*
 > * FIND_First *NONE*
 > * FIND_Last *NONE*
 > * FIND_Idx *int*
 > * FIND_Key *any*
 > * FIND_Val *any*
 > * FIND_Card *Card*
 > * FIND_Size *int*
 > * FIND_Height *int*
 > * FIND_Slice *[2]int representing all between idx range*
 > * FIND_All *NONE*
 > * FIND_Lambda *lambda function*

 > **REPLACE**
 > * _REPLACE_NotationSample *setByData argument type*
 > * REPLACE_Key *any*
 > * REPLACE_Val *any*
 > * REPLACE_Card *Card*
 > * REPLACE_Stack *Stack*
 > * REPLACE_Lambda *lambda function*

 > **TYPE**
 > * TYPE_Key
 > * TYPE_Val

 > **ORDER**
 > * ORDER_Before
 > * ORDER_After

 > **DEREFERENCE**
 > * DEREFERENCE_None
 > * DEREFERENCE_Both

 > **CLONE**
 > * CLONE_True
 > * CLONE_False

 > **DEEPSEARCH**
 > * DEEPSEARCH_True
 > * DEEPSEARCH_False

 > **COMPARE**
 > * COMPARE_True
 > * COMPARE_False

 > **PASS**
 > * PASS_True
 > * PASS_False

<h2 name = "nonGeneralizedFunctionsBrief">Non-Generalized Functions</h2>

 * **MakeCard(...idx, ...key, ...val)**
 * **MakeStack(...input1, ...input2, ...repeats)**
 * **MakeStackMatrix(...input1, ...input2, ...matrixShape)**
 * **stack.StripStackMatrix(target1, target2, ..., targetN)**
 * **stack.ToArray()**
 * **stack.ToMap()**
 * **stack.ToMatrix(...depth)**
 * **stack.IsRegular()**
 * **stack.Shape()**
 * **stack.Duplicate(...n)**
 * **stack.Empty()**
 * **card.Clone(...cloneKey, ...cloneVal)**
 * **stack.Clone(...cloneCards, ...cloneKeys, ...cloneVals)**
 * **stack.Unique(typeType, ...dereferenceType, ...deepSearchType, ...depth)**
 * **card.Equals(Card, ...pointerKeys, ...pointerVals, ...compareIdxs, ...printType)**
 * **stack.Equals(Stack, ...compareStacks, ...dereferenceTypeStack, ...deepSearchType, ...depth, ...pointerKeys, ...pointerVals)**
 * **stack.Shuffle()**
 * **stack.Transpose()**
 * **card.Print()**
 * **stack.Print()**
 * **stack.Lambda(lambda function, ...deepSearchType, ...depth)**
 * **stack.LambdaThis(lambda function, ...deepSearchType, ...depth)**
 * **stack.LambdaStack(lambda function, ...deepSearchType, ...depth)**
 * **stack.LambdaCard(lambda function, ...deepSearchType, ...depth)**
 * **stack.LambdaVarAdr(lambda function, ...deepSearchType, ...depth)**

<h2 name = "generalizedFunctionsBrief">Generalized Functions</h2>

 * **stack.Add(insert, ...orderType, ...findType, ...findData, ...dereferenceType, ...deepSearchType, ...depth, ...overrideStackConversion)**
 * **stack.AddMany(insert, ...orderType, ...findType, ...findData, ...dereferenceType, ...deepSearchType, ...depth, ...overrideStackConversion)**
 * **stack.Move(findType_from, orderType, findType_to, ...findData_from, ...findData_to, ...dereferenceType_from, ...dereferenceType_to, ...deepSearchType, ...depth)**
 * **stack.Swap(findType_from, findType_to, ...findData_from, ...findData_to, ...dereferenceType_from, ...dereferenceType_to, ...deepSearchType, ...depth)**
 * **stack.Has(returnType, findType, ...findData, ...dereferenceType, ...deepSearchType, ...depth)**
 * **stack.Get(...findType, ...findData, ...dereferenceType, ...clonesType_card, ...clonesType_keys, ...clonesType_vals, ...deepSearchType, ...depth)**
 * **stack.GetMany(findType, ...findData, ...dereferenceType, ...returnType, ...clonesType, ...clonesType_keys, ...clonesType_vals, ...deepSearchType, ...depth)**
 * **stack.Replace(replaceType, replaceData, findType, ...findData, ...dereferenceType, ...deepSearchType, ...depth)**
 * **stack.ReplaceMany(replaceType, replaceData, findType, ...findData, ...dereferenceType, ...returnType, ...deepSearchType, ...depth)**
 * **stack.Update(findType, ...findData, ...dereferenceType, ...deepSearchType, ...depth)**
 * **stack.UpdateMany(findType, ...findData, ...dereferenceType, ...deepSearchType, ...depth)**
 * **stack.Extract(findType, ...findData, ...dereferenceType, ...deepSearchType, ...depth)**
 * **stack.ExtractMany(findType, ...findData, ...dereferenceType, ...returnType, ...deepSearchType, ...depth)**
 * **stack.Remove(findType, ...findData, ...dereferenceType, ...deepSearchType, ...depth)**
 * **stack.RemoveMany(findType, ...findData, ...dereferenceType, ...deepSearchType, ...depth)**

<h1 name = "exhaustiveDocumentation">Exhaustive Documentation</h1>

<h2 name = "dataStructures">Data Structures</h2>

<h3 name = "structs">structs</h3>

<h4 name = "stack">Stack</h4>

 This is the main struct in the project.

 > `stack` *Stack{}*
 >> `Cards` *[]\*Card{}*
 >>> Returns an interface array to represent the elements in the Stack
 >>
 >> `Size` *int*
 >>> Returns the cardinality (i.e., `len(stack.Cards)`) of this Stack
 >>
 >> `Height` *int*
 >>> Returns the dimensionality of this Stack, assuming it is uniform

<h4 name = "card">Card</h4>

 This is a struct for our elements/maps within stacks.

 >> `Card` *Card{}*
 >>> `card.Idx` *int*
 >>>> The index of this card
 >>>
 >>> `card.Key` *any*
 >>>> The key of this card (or nil if doesn't exist)
 >>>
 >>> `card.Val` *any*
 >>>> The val of this card (or nil if doesn't exist)

<h3 name = "enums">enums</h3>

Please note that enumerator defaults are default in *most cases*.  However, you should defer to each function's documentation to see the actual argument default values.

<h4 name = "RETURN">RETURN</h4>

 This is an enum intended to make it easy for the user to control the output type from a getter function.

 > ***RETURN***
 >> *_RETURN_NotationSample*
 >>> *If you input RETURN_Keys to stack.GetMany(), then you will get a new stack of cards whose values are the keys of the initial stack.*
 >>
 >> RETURN_Idxs
 >>> stack of ints
 >>
 >> RETURN_Keys
 >>> stack of anys
 >>
 >> RETURN_Vals
 >>> stack of anys
 >>
 >> RETURN_Cards
 >>>> default
 >>>
 >>> stack of Cards

<h4 name = "FIND">FIND</h4>

 This is an enum intended to make it easy to flexibly inform functions what the intended target is.

 > ***FIND***
 >> *_FIND_NotationSample*
 >>> *The type of the variable (called `data`) that needs to be passed into the function utilizing this constant*
 >>
 >>> *For instance, if you input `FIND_Keys`, you would need to pass a Stack whose values are the keys you want to find to your `data` parameter*
 >>
 >> FIND_First
 >>>
 >>> *NONE*
 >>
 >> FIND_Last
 >>>> default
 >>> *NONE*
 >>
 >> FIND_Idx
 >>> int
 >>
 >> FIND_Idxs
 >>> []int
 >>
 >> FIND_IdxsStack
 >>> stack where type{stack.Card.Val} == int
 >>
 >> FIND_Key
 >>> any
 >>
 >> FIND_Keys
 >>> []any
 >>
 >> FIND_KeysStack
 >>> stack where type{stack.Card.Val} == any
 >>
 >> FIND_Val
 >>> any
 >>
 >> FIND_Vals
 >>> []any
 >>
 >> FIND_ValsStack
 >>> stack where type{stack.Card.Val} == any
 >>
 >> FIND_Card
 >>> *Card
 >>
 >> FIND_Cards
 >>> *Stack (input is the cards in this stack)
 >>
 >> FIND_CardsStack
 >>> stack where type{stack.Card.Val} == *Card
 >>
 >> FIND_Slice
 >>> [2]int
 >>>> [startIndex, endIndex]
 >>>>
 >>>> *(if endIndex is lower than startIndex, the find will transpire in reverse order)*
 >>
 >> FIND_All
 >>> *NONE*
 >>
 >> FIND_Lambda
 >>> *lambda function*

<h4 name = "REPLACE">REPLACE</h4>

 This is an enum intended to make it easy to flexibly decide what part of an object to update.  For instance, you could replace a card with a card, replace a card's value with a value, etc, so you are not just limited to replacing cards.

 > ***REPLACE***
 >> *_REPLACE_NotationSample*
 >>> *The type of the variable (called `data`) that needs to be passed into the function utilizing this constant*
 >>
 >> REPLACE_Key
 >>> *any*
 >>
 >> REPLACE_Val
 >>> *any*
 >>
 >> REPLACE_Card
 >>> *Card*
 >>
 >> REPLACE_Stack
 >>> *Stack*
 >>>> replaces a card with each card in a stack of cards
 >>
 >> REPLACE_Lambda
 >>> any *lambda function*
 
<h4 name = "TYPE">TYPE</h4>

 This is an enum intended to make it easy to tell certain functions the type of value being targeted.

> ***TYPE***
>> TYPE_Key
>
>> TYPE_Val
 
<h4 name = "ORDER">ORDER</h4>

 This is an enum intended to make it easy to tell certain functions whether to insert a value before or after the input index.

> ***ORDER***
>> ORDER_Before
>>
>> ORDER_After
>>> default

<h4 name = "DEREFERENCE">DEREFERENCE</h4>

 This is an enum intended to make it easy to target whether a function searching for a match between input data and data in the stack element is matching by having the same values (DEREFERENCE_None) or the same memory address (DEREFERENCE_Both).

 Matching by reference only works for Val, Key, and Card FIND types.  It would not make much sense to match an index that's managed on the backend by reference (FIND_Idx), to match a lambda expression (FIND_Lambda), or to match using a position that's not even comparing values (FIND_First, FIND_Last, FIND_All).

 Take care to note that all cases where objects are matching by reference will also be matching by object.

 > ***DEREFERENCE***
 >> DEREFERENCE_None
 >>> default
 >>
 >> DEREFERENCE_Both

<h4 name = "CLONE">CLONE</h4>

 This is an enum intended to make it possible to tell the function whether to return a clone of an object or a pointer of an object.

 > ***DEREFERENCE***
 >> CLONE_True
 >>> default
 >>
 >> CLONE_False

<h4 name = "DEEPSEARCH">DEEPSEARCH</h4>

 This is an enum intended to make it easy to call functions to perform on certain elements in matrices.

 > ***DEEPSEARCH***
 >> DEEPSEARCH_True
 >>> default
 >>
 >> DEEPSEARCH_False

<h4 name = "COMPARE">COMPARE</h4>

 This is an enum intended to make it easy to call functions to decide whether to compare things in Equals tests.

 > ***COMPARE***
 >> COMPARE_True
 >>> default
 >>
 >> COMPARE_False

<h4 name = "PASS">PASS</h4>

 This is an enum intended to make it easy to determine whether you are considering substacks or cards in the Lambda function.

 > ***PASS***
 >> PASS_True
 >>> default
 >>
 >> PASS_False

<h2 name = "nonGeneralizedFunctions">Non-Generalized Functions</h2>

<h3 name = "MakeCard">MakeCard</h3>

 `gostack.MakeCard(...val, ...key, ...idx)`
 ```
 Makes a card with inputted vals and keys

 @param optional `val` type{any} default nil
 @param optional `key` type{any} default nil
 @param optional `idx` type{int} default -1 no pass-by-reference
 @returns type{*Card} the newly-constructed card
 @constructs type{*Card} a newly-constructed card
 @ensures the new card will have val `val`, key `key`, and idx `idx`
 ```

<h3 name = "MakeStack">MakeStack</h3>

 `gostack.MakeStack(...input1, ...input2, ...repeats)`
 ```
 Creates a stack of cards with optional starting cards
 
 @param optional `input1` type{[]any, map[any]any} default nil
 @param optional `input2` type{[]any} default nil
 @param optional `repeats` type{int} default 1
 @returns type{*Stack} the newly-constructed stack of newly-constructed cards
 @constructs type{*Stack} a newly-constructed stack of newly-constructed cards
 @requires
  * `input1` is map and nil `input2`
      OR `input1` is an array and nil `input2`
	  OR `input1` is an array and `input2` is an array
	  OR `input1` is nil and `input2` is an array
  * IF `input1` and `input2` are both passed as arguments
      |`input1`| == |`input2`|
  * `MakeCard()` has been implemented
 @ensures
  * repeats the function's filling `repeats` (or, if nil or under 0, 1) amount of times
  * IF `input1` is passed
	    IF `input1` is a map
        unpack the map into new cards with corresponding keys and vals
      ELSEIF `input1` is an array and `input2` is not passed/nil
        unpack values from `input1` into new cards
      ELSEIF `input1` is an array and `input2` is an array
	      unpack keys from `input1` and values from `input2` into new cards
      ELSEIF `input1` is nil and `input2` is an array
	      unpack keys from `input2` into new cards
	  ELSE
	    the stack is empty
 ```

<h3 name = "MakeStackMatrix">MakeStackMatrix</h3>

 `MakeStackMatrix(...input1, ...input2, ...matrixShape)`
 ```
 Creates a new stack-within-stack-structured stack
 
 @param optional `input1` type{any} default nil
 @param optional `input2` type{any} default nil
 @param optional `matrixShape` type{[]int} default nil
  * an int array representing the shape of the matrix
  * the first int is the largest container
  * the last int is the container directly containing the inputted cards
 @requires
  * `MakeCard()` has been implemented
  * IF `input1` and `input2` are both passed as arguments
      |`input1`| == |`input2`|
 @ensures
  * IF no `matrixShape` is passed
      treating `input1`/`input2` as matrices/a map of matrices:
      IF `input1` is passed
        IF `input1` is a map
          unpack the map into matrix of shape `inputx` with corresponding keys and vals
        ELSEIF `input1` is an array and `input2` is not passed/nil
          unpack values from `input1` into matrix of shape `inputx`
        ELSEIF `input1` is an array and `input2` is an array
          unpack keys from `input1` and values from `input2` into matrix of shape `inputx`
        ELSEIF `input1` is nil and `input2` is an array
          unpack keys from `input2` into matrix of shape `inputx` 
      ELSEIF `input1` is not passed
        the stack is empty
	ELSEIF `matrixShape` is passed
	  treating `input1`/`input2` as 1D arrays:
	  IF `input1` is passed
        IF `input1` is a map
          unpack the map into matrix of shape `matrixShape` with corresponding keys and vals
        ELSEIF `input1` is an array and `input2` is not passed/nil
          unpack values from `input1` into matrix of shape `matrixShape`
        ELSEIF `input1` is an array and `input2` is an array
          unpack keys from `input1` and values from `input2` into matrix of shape `matrixShape`
        ELSEIF `input1` is nil and `input2` is an array
          unpack keys from `input2` into matrix of shape `matrixShape`
	  ELSEIF `input1` is not passed
	    create a StackMatrix of shape `matrixShape` whose heightest card vals are nil
 ```
 
<h3 name = "StripStackMatrix">StripStackMatrix</h3>
 
 `stack.StripStackMatrix()`
 ```
 Returns a stack representing a selection within a stack matrix
 
 @receiver `stack` type{*Stack}
 @param variadic `selections` type{int, []int} a set of args representing the indices being selected within an array
 @returns type{*Stack} a new Stack representing the selection
 @constructs type{*Stack} a new Stack representing the selection
 @requires `idx` arguments get valid index positions from the stack
 ```
 
<h3 name = "ToArray">ToArray</h3>
 
 `stack.ToArray()`
 ```
 Creates a new interface array from values of `stack`

 @receiver `stack` type{*Stack}
 @returns type{[]any} new array
 @ensures new array values correspond to `stack` values
 ```
 
<h3 name = "ToMap">ToMap</h3>
 
 `stack.ToMap()`
 ```
 Creates a new interface-interface map from values of `stack`

 @receiver `stack` type{*Stack}
 @returns type{map[any]any} new map
 @ensures new map keys and values correspond to `stack` keys and values
 ```
 
<h3 name = "ToMatrix">ToMatrix</h3>
 
 `stack.ToMatrix(...depth)`
 ```
 Creates a new matrix from a stack by depth.  For instance, if depth = 2, then returns the stacks inside stack as an [][]any

 @receiver `stack` type{*Stack}
 @param optional `depth` type{int} default -1
 @returns type{[]interface}
 @ensures
  * -1 depth means it will go as depth as it can
  * new map keys and values correspond to `stack` keys and values
  * example: Stack{Stack{"Hi"}, Stack{"Hello", "Hola"}, "Hey"} =>
      []any{[]any{"Hi"}, []any{"Hola", "Hello"}, "Hey"}
 ```
 
<h3 name = "IsRegular">IsRegular</h3>
 
 `stack.IsRegular()`
 ```
 Returns whether the matrix is of a regular shape

 @receiver `stack` type{*Stack}
 @returns type{bool}
 @ensures
   * example:
       {{1, 2}, 3} == irregular/false
       {{1, 2}, {3}} == irregular/false
       {{1, 2}, {3, 4}} == regular/true
	   {1, 3} == regular/true
	   {} == regular/true
 ```
 
<h3 name = "Shape">Shape</h3>
 
 `stack.Shape()`
 ```
 Returns the shape of this stackMatrix, or nil if irregular shape

 @receiver `stack` type{*Stack}
 @returns type{[]int}
 ```
 
<h3 name = "Duplicate">Duplicate</h3>
 
 `stack.Duplicate(n ...int)`
 ```
 Adds the cards in `stack` to itself `n` - 1 times
  (duplicate 4 means 3 duplicates made; duplicate 1 means don't duplicate; duplicate 0 means empty)
 
 @receiver `stack` type{*Stack}
 @param optional `n` type{int} default 2
 @updates `stack`
 @returns `stack`
 ```
 
<h3 name = "Empty">Empty</h3>
 
 `stack.Empty()`
 ```
 Makes a card with inputted vals and keys

 @receiver `stack` type{*Stack}
 @returns `stack`
 @updates `stack.Cards` to be empty
 ```

<h3 name = "Clone">Clone</h3>

 `card.Clone(...cloneKey, ...cloneVal)`
 ```
 Returns a clone of the given card

 @receiver `card` type{*Card}
 @returns type{*Card} card clone
 @constructs clone of `card`
 ```

 `stack.Clone(...cloneCards, ...cloneKeys, ...cloneVals)`
 ```
 Returns a clone of the given stack

 @receiver `stack` type{*Stack}
 @returns type{*Stack} stack clone
 @constructs type{*Stack} clone of `stack`
 @ensures the stack clone has the same card pointers as `stack`
 ```
 
<h3 name = "Unique">Unique</h3>
 
 `stack.Unique(typeType, ...dereferenceType, ...deepSearchType, ...depth)`
 ```
 Removes all cards from `stack` which share the same field value as another card before

 @receiver `stack` type{*Stack}
 @param `typeType` type{TYPE}
 @param optional `dereferenceType` type{DEREFERENCE} default DEREFERENCE_None
 @returns `stack`
 @updates `stack` to have no repeating values between field `typeType`
 ```
 
<h3 name = "Equals">Equals</h3>
 
 `card.Equals(*Card, ...compareCards, ...dereferenceTypeCard, ...pointerKeys, ...pointerVals, ...compareIdxs)`
 ```
 Returns whether two cards equal one another
 
 @receiver `thisCard` type{*Card}
 @param `otherCard` type{*Card}
 @param optional `pointerKeys` type{DEREFERENCE} default DEREFERENCE_None
 @param optional `pointerVals` type{DEREFERENCE} default DEREFERENCE_None
 @param optional `compareIdxs` type{bool} default false
 @returns type{bool}
 ```
 
 `stack.Equals(*Stack, ...compareStacks, ...dereferenceTypeStack, ...deepSearchType, ...compareCards, ...dereferenceTypeCard, ...pointerKeys, ...pointerVals)`
 ```
 Returns whether two stacks equal one another
 
 @receiver `thisStack` type{*Stack}
 @param `otherStack` type{*Stack}
 @param optional `compareStacks` type{COMPARE} default COMPARE_False
	By default, does not compare the stack structs, but rather their cards; can be set true and adjusted with `dereferenceTypeStack`
 @param optional `dereferenceTypeStack` type{DEREFERENCE} default DEREFERENCE_None
 @param optional `deepSearchType` type{DEEPSEARCH} default DEEPSEARCH_False
 @param optional `depth` type{int} default -1 (heightest)
 @param optional `pointerKeys` type{DEREFERENCE} default DEREFERENCE_None
 @param optional `pointerVals` type{DEREFERENCE} default DEREFERENCE_None
 @returns type{bool}
 ```
 
<h3 name = "Shuffle">Shuffle</h3>
 
 `stack.Shuffle()`
 ```
 Shuffles the order of `stack` cards

 @receiver `stack` type{*Stack}
 @returns `stack`
 @updates
  * `stack` card ordering is randomized
  * rand.Seed is updated to time.Now().UnixNano()
 ```
 
<h3 name = "Transpose">Transpose</h3>
 
 `stack.Transpose()`
 ```
 Transposes the ordering of `stack.Cards`
 
 @receiver `stack` type{*Stack}
 @returns `stack`
 @updates `stack` to have its ordering reversed
 ```
 
<h3 name = "Print">Print</h3>
 
 `card.Print()`
 ```
 Prints information regarding `card` to the console
 
 @receiver `card` type{*Card}
 @updates terminal logs
 ```
 
 `stack.Print()`
 ```
 Prints information regarding `stack` to the console
 
 @receiver `stack` type{*Stack}
 @updates terminal logs
 @requires card.Print() has been implemented
 ```
 
<h3 name = "Lambda">Lambda</h3>
 
 `stack.Lambda(lambda function, ...deepSearchType, ...depth)`
 ```
 Iterate through a stack calling your lambda function on each card
 
 @receiver `stack` type{*Stack}
 @param `lambda` type{func(*Card, ...any)}
 @ensures
  * Each card in `stack` is passed into your lambda function
  * `stack` is the first argument passed into your variadic parameter on the first call
 ```
 
 `stack.LambdaThis(lambda function, ...deepSearchType, ...depth)`
 ```
 Iterate through a stack calling your lambda function on each card
 
 @receiver `stack` type{*Stack}
 @param `lambda` type{func(*Card, ...any)}
 @ensures
  * Each card in `stack` is passed into your lambda function
  * `stack` is the first argument passed into your variadic parameter on the first call
 ```
 
 `stack.LambdaStack(lambda function, ...deepSearchType, ...depth)`
 ```
 Iterate through a stack calling your lambda function on each card
 
 @receiver `stack` type{*Stack}
 @param `lambda` type{func(*Card, ...any)}
 @ensures
  * Each card in `stack` is passed into your lambda function
  * `stack` is the first argument passed into your variadic parameter on the first call
 ```
 
 `stack.LambdaCard(lambda function, ...deepSearchType, ...depth)`
 ```
 Iterate through a stack calling your lambda function on each card
 
 @receiver `stack` type{*Stack}
 @param `lambda` type{func(*Card, ...any)}
 @ensures
  * Each card in `stack` is passed into your lambda function
  * `stack` is the first argument passed into your variadic parameter on the first call
 ```
 
 `stack.LambdaVarAdr(lambda function, ...deepSearchType, ...depth)`
 ```
 Iterate through a stack calling your lambda function on each card
 
 @receiver `stack` type{*Stack}
 @param `lambda` type{func(*Card, ...any)}
 @ensures
  * Each card in `stack` is passed into your lambda function
  * `stack` is the first argument passed into your variadic parameter on the first call
 ```

<h2 name = "generalizedFunctions">Generalized Functions</h2>
 
<h3 name = "Add">Add</h3>
 
 `stack.Add(insert, ...orderType, ...findType, ...findData, ...dereferenceType, ...deepSearchType, ...depth, ...overrideStackConversion)`
 ```
 Adds to a stack of cards or a cards at (each) position(s) and returns `stack`
 
 @receiver `stack` type{*Stack}
 @param `insert` type{Card, Stack}
 @param optional `orderType` type{ORDER} default ORDER_Before
 @param optional `findType` type{FIND} default FIND_First
 @param optional `findData` type{any} default nil
 @param optional `dereferenceType` type{DEREFERENCE} default DEREFERENCE_None
 @param optional `deepSearchType` type{DEEPSEARCH} default DEEPSEARCH_False
 @param optional `depth` type{int} default -1 (heightest)
 @param optional `overrideStackConversion` type{bool} default false
	if `insert` is of type Stack:
		if not `overrideStackConversion`:
			add to `stack` from `insert.Cards`
		else if `overrideStackConversion`:
			add the `insert` stack to `stack` as the val of a card
 @returns `stack` if cards were added OR nil if no cards were added (due to invalid find)
 @updates `stack` to have new cards before/after each designated position
 @requires `stack.Clone()` has been implemented
 ```
 
<h3 name = "AddMany">AddMany</h3>
 
 `stack.AddMany(insert, ...orderType, ...findType, ...findData, ...dereferenceType, ...deepSearchType, ...depth, ...overrideStackConversion)`
 ```
TODO: Add
 ```
 
<h3 name = "Move">Move</h3>
 
 `stack.Move(findType_from, orderType, findType_to, ...findData_from, ...findData_to, ...dereferenceType_from, ...dereferenceType_to)`
 ```
 Moves one element or slice of cards to before or after another element or slice of cards
 
 @receiver `stack` type{*Stack}
 @param `findType_from` type{FIND}
 @param `orderType` type{ORDER}
 @param `findType_to` type{FIND}
 @param optional `findData_from` type{any} default nil
 @param optional `findData_to` type{any} default nil
 @param optional `dereferenceType_from` type{DEREFERENCE} default DEREFERENCE_None
 @param optional `dereferenceType_to` type{DEREFERENCE} default DEREFERENCE_None
 @param optional `deepSearchType_from` type{DEEPSEARCH} default DEEPSEARCH_False
 @param optional `deepSearchType_to` type{DEEPSEARCH} default DEEPSEARCH_False
 @param optional `height_from` type{int} default -1 (heightest)
 @param optional `height_to` type{int} default -1 (heightest)
 @returns `stack` if moved OR nil if no move occurred (due to bad find)
 @requires you are not moving a stack to a location within that own stack
 @ensures a stack of cards, or individual cards, can be targeted
 ```
 
<h3 name = "Swap">Swap</h3>
 
 `stack.Swap(findType_from, findType_to, ...findData_from, ...findData_to, ...dereferenceType_from, ...dereferenceType_to, ...deepSearchType, ...depth)`
 ```
 Swaps one element or slice with the position of another element or slice
 
 @receiver `stack` type{*Stack}
 @param `findType_first` type{FIND}
 @param `findType_second` type{FIND}
 @param optional `findData_first` type{any} default nil
 @param optional `findData_second` type{any} default nil
 @param optional `dereferenceType_first` type{DEREFERENCE} default DEREFERENCE_None
 @param optional `dereferenceType_second` type{DEREFERENCE} default DEREFERENCE_None
 @param optional `deepSearchType_first` type{DEEPSEARCH} default DEEPSEARCH_False
 @param optional `deepSearchType_second` type{DEEPSEARCH} default DEEPSEARCH_False
 @param optional `height_first` type{int} default -1 (heightest)
 @param optional `height_second` type{int} default -1 (heightest)
 @returns `stack` if moved OR nil if no move occurred (due second bad find)
 @requires you are not swapping a stack with a location within that own stack
 @ensures a stack of cards, or individual cards, can be targeted
 ```
 
<h3 name = "Has">Has</h3>
 
 `stack.Has(...findType, ...findData, ...dereferenceType)`
 ```
 Returns a boolean representing whether a search exists in the stack

 @receiver `stack` type{*Stack}
 @param optional `findType` type{FIND} default FIND_First
 @param optional `findData` type{any} default nil
 @param optional `dereferenceType` type{DEREFERENCE} default DEREFERENCE_None
 @returns true IF successful search, false IF unsuccessful search
 @requires `stack.Get()` has been implemented
 ```
 
<h3 name = "Get">Get</h3>
 
 `stack.Get(...findType, ...findData, ...dereferenceType, ...clonesType_card, ...clonesType_keys, ...clonesType_vals)`
 ```
 Gets a card from specified parameters in a stack, or nil if does not exist

 @receiver `stack` type{*Stack}
 @param optional `findType` type{FIND} default FIND_First
 @param optional `findData` type{any} default nil
 @param optional `dereferenceType` type{DEREFERENCE} default DEREFERENCE_None
 @param optional `clonesType_card` type{CLONES} default CLONE_FALSE
 @param optional `clonesType_keys` type{CLONES} default CLONE_FALSE
 @param optional `clonesType_vals` type{CLONES} default CLONE_FALSE
 @returns type{*Card} the found card OR nil if invalid FIND
 @ensures
  * CLONE_True for `clonesType_card` means the returned card object itself is a clone
  * CLONE_True for `clonesType_key` means the returned card key is a clone
  * CLONE_True for `clonesType_val` means the returned card val is a clone
 ```
 
<h3 name = "GetMany">GetMany</h3>
 
 `stack.GetMany(findType, ...findData, ...returnType, ...dereferenceType, ...clonesType, ...clonesType_keys, ...clonesType_vals)`
 ```
 Gets a stack from specified parameters in a stack
 
 @receiver `stack` type{*Stack}
 @param `findType` type{FIND}
 @param optional `findData` type{any} default nil
 @param optional `returnType` type{RETURN} default RETURN_Cards
 @param optional `dereferenceType` type{DEREFERENCE} default DEREFERENCE_None
 @param optional `clonesType` type{CLONES} default CLONE_False
 @param optional `clonesType_keys` type{CLONES} default CLONE_False
 @param optional `clonesType_vals` type{CLONES} default CLONE_False
 @param optional `deepSearchType` type{DEEPSEARCH} default DEEPSEARCH_False
 @param optional `depth` type{int} default -1 (heightest)
 @returns type{*Stack} the new stack (if find fails, then an empty stack)
 @constructs type{*Stack} new stack of specified values from specified cards in `stack`
 @requires
  * `MakeStack()` has been implemented
  * `clonesType_keys` and `clonesType_vals` are only passed if `returnType` == RETURN_Cards
 @ensures
  * CLONE_True means the cards in the returned stack are clones
  * CLONE_True for `clonesType_keys` means the cards in the returned stack keys are clones
  * CLONE_True for `clonesType_vals` means the cards in the returned stack vals are clones
 ```
 
<h3 name = "Replace">Replace</h3>
 
 `stack.Replace(replaceType, replaceData, findType, ...findData, ...dereferenceType)`
 ```
 Returns a clone of a found card before its respective field is updated to `replaceData` (OR nil if not found)
 
 @receiver `stack` type{*Stack}
 @param `replaceType` type{REPLACE}
 @param `replaceData` type{any}
 @param `findType` type{FIND}
 @param optional `findData` type{any} default nil
 @param optional `dereferenceType` type{DEREFERENCE} default DEREFERENCE_None
 @returns type{*Card} a clone of extracted card OR nil if found no cards
 @updates first found card to `replaceData`
 @requires `stack.Get()` has been implemented
 @ensures if `replaceData` is nil and `replaceType is REPLACE_Card`, the card will be removed from `stack`
 ```
 
<h3 name = "ReplaceMany">ReplaceMany</h3>
 
 `stack.Replace(replaceType, replaceData, findType, ...findData, ...returnType, ...dereferenceType)`
 ```
 Returns a stack whose values are the original fields updated to `replaceData`
 
 @receiver `stack` type{*Stack}
 @param `replaceType` type{REPLACE}
 @param `replaceData` type{any}
 @param `findType` type{FIND}
 @param optional `findData` type{any} default nil
 @param optional `returnType` type{RETURN} default RETURN_Cards
 @param optional `dereferenceType` type{DEREFERENCE} default DEREFERENCE_None
 @param optional `deepSearchType` type{DEEPSEARCH} default DEEPSEARCH_False
 @param optional `depth` type{int} default -1 (heightest)
 @returns type{*Stack} a stack whose values are the extracted cards pre-update (if find fails, then an empty stack)
 @updates all found cards to `replaceData`
 @requires `stack.GetMany()` has been implemented
 @ensures IF `replaceData` is nil and `replaceType is REPLACE_Card`, the cards found will be removed from `stack`
 ```
 
<h3 name = "Update">Update</h3>
 
 `stack.Update(findType, ...findData, ...dereferenceType)`
 ```
 Updates a card in and returns `stack`
 
 @receiver `stack` type{*Stack}
 @param `findType` type{FIND}
 @param optional `findData` type{any} default nil
 @param optional `dereferenceType` type{DEREFERENCE} default DEREFERENCE_None
 @returns `stack`
 @updates the found card in `stack`
 @requires `stack.Replace()` has been implemented
 ```
 
<h3 name = "UpdateMany">UpdateMany</h3>
 
 `stack.UpdateMany(findType, ...findData, ...dereferenceType)`
 ```
 Updates cards in and returns `stack`
 
 @receiver `stack` type{*Stack}
 @param `findType` type{FIND}
 @param optional `findData` type{any} default nil
 @param optional `dereferenceType` type{DEREFERENCE} default DEREFERENCE_None
 @returns `stack`
 @updates  the found cards in `stack`
 @requires `stack.ReplaceMany()` has been implemented
 ```
 
<h3 name = "Extract">Extract</h3>
 
 `stack.Extract(findType, ...findData, ...dereferenceType)`
 ```
 Gets and removes a card from `stack`, or returns nil if it does not exist
 
 @receiver `stack` type{*Stack}
 @param `findType` type{FIND}
 @param optional `findData` type{any} default nil
 @param optional `dereferenceType` type{DEREFERENCE} default DEREFERENCE_None
 @returns type{*Card} the extracted card OR nil if invalid FIND
 @updates `stack` to no longer have found card
 ```
 
<h3 name = "ExtractMany">ExtractMany</h3>
 
 `stack.ExtractMany(findType, ...findData, ...returnType, ...dereferenceType)`
 ```
 Gets and removes a set of data from `stack`
 
 @receiver `stack` type{*Stack}
 @param `findType` type{FIND}
 @param optional `findData` type{any} default nil
 @param optional `returnType` type{RETURN} default RETURN_Cards
 @param optional `dereferenceType` type{DEREFERENCE} default DEREFERENCE_None
 @param optional `deepSearchType` type{DEEPSEARCH} default DEEPSEARCH_False
 @param optional `depth` type{int} default -1 (heightest)
 @returns type{*Stack} the extracted card (if find fails, then an empty stack)
 @updates `stack` to no longer have found cards
 @requires `stack.ReplaceMany()` has been implemented
 ```
 
<h3 name = "Remove">Remove</h3>
 
 `stack.Remove(findType, ...findData, ...dereferenceType)`
 ```
 Removes a card from and returns `stack`
 
 @receiver `stack` type{*Stack}
 @param `findType` type{FIND}
 @param optional `findData` type{any} default nil
 @param optional `dereferenceType` type{DEREFERENCE} default DEREFERENCE_None
 @returns `stack`
 @updates `stack` to no longer have found card
 @requires `stack.Replace()` has been implemented
 ```
 
<h3 name = "RemoveMany">RemoveMany</h3>
 
 `stack.RemoveMany(findType, ...findData, ...dereferenceType)`
 ```
 Removes a set of cards from and returns `stack`
 
 @receiver `stack` type{*Stack}
 @param `findType` type{FIND}
 @param optional `findData` type{any} default nil
 @param optional `dereferenceType` type{DEREFERENCE} default DEREFERENCE_None
 @returns `stack`
 @updates `stack` to no longer have found cards
 @requires `stack.ReplaceMany()` has been implemented
 ```
 
<h2 name = "futureUpdates">Future Updates</h2>

 *To be added later*

/*
func gostack_back_AddCard(stack *Stack, card *Card, idx any, beforeNotAfter bool) *Stack {

	// insert card into new array slice to satisfy append function
	newCards := []*Card{}

	if stack.size == 0 { // add card to empty list

		newCards = append(newCards, card)

	} else { // append each card in stack.cards to card

		if beforeNotAfter {

			for i := range stack.cards {
				c := stack.cards[i]
				if i != idx {
					newCards = append(newCards, c)
				} else if i == idx {
					newCards = append(newCards, card)
					newCards = append(newCards, c)
				}
			}

			if idx == stack.size {
				newCards = append(newCards, card)
			}

		} else {

			for i := range stack.cards {
				c := stack.cards[i]
				if i != idx {
					newCards = append(newCards, c)
				} else if i == idx {
					newCards = append(newCards, c)
					newCards = append(newCards, card)
				}
			}

		}

	}

	// set stack.cards to our new array
	stack.cards = newCards

	// update stack properties
	stack.size++

	// return
	return stack

}

func gostack_back_ExtractCard(stack *Stack, idx any) (card *Card) {

	if stack.size == 0 { // if we can't pop it, return nil

		card = nil

	} else { // if we can pop it, return popped card

		// insert card into new array slice to satisfy append function
		newCards := []*Card{}

		// append each card in stack.cards to card
		for i := range stack.cards {
			c := stack.cards[i]
			if i != idx {
				newCards = append(newCards, c)
			} else if i == idx {
				card = c
			}
		}

		// set stack.cards to our new array
		stack.cards = newCards

		// update stack properties
		stack.size--

	}

	return

}

func gostack_back_UpdatePosData(_data ...any) (data any) {
	if len(_data) == 1 {
		data = _data[0] // just so there is only one optional param
	} else {
		data = nil
	}
	return
}

func gostack_back_GetIdxFromData(stack *Stack, position FIND, _data ...any) (idx int) {
	return gostack_back_GetIdxFromPosition(stack, position, gostack_back_UpdatePosData(_data)).(int)
}

// returns index of searched item if valid
// else, returns -1
func gostack_back_GetIdxFromPosition(stack *Stack, position FIND, _data ...any) (idx any) {

	data := gostack_back_UpdatePosData(_data...)

	switch position {

	case FIND_First:
		idx = 0 // nil
	case FIND_Last:
		idx = stack.size - 1 // nil
	case FIND_Card:
		idx = -1
		for i, c := range stack.cards {
			if c == data { // key
				idx = i
				break
			}
		}
	case FIND_Idx:
		idx = data // int
	case FIND_Key:
		idx = -1
		for i, c := range stack.cards {
			if c.key == data { // key
				idx = i
				break
			}
		}
	case FIND_Val:
		idx = -1
		for i, c := range stack.cards {
			if c.val == data { // card
				idx = i
				break
			}
		}

	}

	return

}
*/

/*
func (stack *Stack) Extract(position FIND, data ...any) *Card {

	// get idx
	idx := gostack_back_GetIdxFromData(stack, position, data)

	// extract card if valid idx
	var extract *Card = nil
	if idx != -1 {
		extract = gostack_back_ExtractCard(stack, idx)
	}

	// return
	return extract

}

func (stack *Stack) Replace(toInsert *[]any, position FIND, data ...any) (oldCards *Stack) {

	// get idx
	idx := gostack_back_GetIdxFromData(stack, position, data)

	if idx != -1 {
		// extract card
		oldCard = gostack_back_ExtractCard(stack, idx)

		// insert card at previous location if got out card
		if oldCard != nil {
			gostack_back_AddCard(stack, toInsert, idx, true)
		}
	}

	// return
	return

}

func (stack *Stack) Get(returnType RETURN, findType FIND, FINDDATA, dereferenceType ...DEREFERENCE) any {



}

func (stack  *Stack) Has(lookFor any, position FIND, data ...any) bool

	// get id
	idx := gostack_back_GetIdxFromData(stack, position, data)

	// retur
	return idx != -1

}
*/
