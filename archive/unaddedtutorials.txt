<h3>...to Demonstrate Flexibility</h3>

 > `stack.Get(RETURN_Card, FIND_First)`
 >> *returns the first card in the Stack*
 >
 > `stack.Get(RETURN_Card, FIND_Val, "String Value", DEREFERENCE_None)`
 >> *goes through the stack, finds the first card with val "String Value", and returns that card*
 >
 > `stack.Get(RETURN_Card, FIND_Key, "String Key", DEREFERENCE_None)`
 >> *goes through the stack, finds the first card with key "String Key", and returns that card*
 >
 > `stack.Get(RETURN_Cards, FIND_Lambda, lambda function)` - update
 >> *goes through the stack, finds each card for which the lambda expression is true, and return a stack of these cards*
 >
 > `stack.Get(RETURN_Cards, FIND_Val, "String Value", DEREFERENCE_None)`
 >> *goes through the stack, finds each card with val "String Value", and returns a Stack of each of those cards*
 >
 > `stack.Get(RETURN_Card, FIND_Val, stackOfValues, DEREFERENCE_None)`
 >> *goes through the stack, finds the first card with one of the values in stackOfValues, and returns that card*
 >
 > `stack.Get(RETURN_Cards, FIND_Val, stackOfValues, DEREFERENCE_None)`
 >> *goes through the stack, finds each card with one of the values in stackOfValues, and returns a Stack of each of those cards*
 >
 > `stack.Get(RETURN_Card, FIND_Val, stackOfValues, DEREFERENCE_Both)`
 >> *goes through the stack, finds the first card with the same memory address as one the values in stackOfValues, and returns that card*
 >
 > `stack.Get(RETURN_Cards, FIND_Val, stackOfValues, DEREFERENCE_Both)`
 >> *goes through the stack, finds each card with a memory address matching one in stackOfValues, and returns a Stack of each of those cards*


 ***TYPE Example Uses***
 
 > `stack.Add(cardToAdd, ORDER_Before, FIND_Last)`
 >> *insert a card at the second-to-last index of the stack*
 >
 > `stack.Add(cardToAdd, ORDER_After, FIND_Last)`
 >> *insert a card at the last index of the stack*

 ***ORDER Example Uses***
 
 > `stack.Add(cardToAdd, ORDER_Before, FIND_Last)`
 >> *insert a card at the second-to-last index of the stack*
 >
 > `stack.Add(cardToAdd, ORDER_After, FIND_Last)`
 >> *insert a card at the last index of the stack*

 ***DEREFERENCE Example Uses***
 
 > `stack.Get(RETURN_Card, FIND_Card, cardStructureToFind, DEREFERENCE_None)`
 >> *returns the first card that has the same structure (key and value) as cardStructureToFind*
 >
 > stack.Get(RETURN_Card, FIND_Card, exactCardToFind, DEREFERENCE_Both)`
 >> *returns the first card that IS exactCardToFind as stored in memoryâ€”not just that's the same structurally*

 ***Stack Example Uses***

 > `stack.size`
 >> *returns the cardinality of the stack's cards (i.e., amount of cards in the stack)*

 ***RETURN Example Uses***
 
 > `stack.Get(RETURN_Card, FIND_Val, "String Value", DEREFERENCE_None)`
 >> *goes through the stack, finds the first card with val "String Value", and returns that card*
 >
 > `stack.Get(RETURN_Cards, FIND_Val, "String Value", DEREFERENCE_None)`
 >> *goes through the stack, finds each card with val "String Value", and returns a Stack of each of those cards*
 >
 > `stack.Get(RETURN_Card, FIND_Val, stackOfValues, DEREFERENCE_None)`
 >> *goes through the stack, finds the first card with one of the values in stackOfValues, and returns that card*
 >
 > `stack.Get(RETURN_Cards, FIND_Val, stackOfValues, DEREFERENCE_None)`
 >> *goes through the stack, finds each card with one of the values in stackOfValues, and returns a Stack of each of those cards*

 ***FIND Example Uses***
 
 > `stack.Get(RETURN_Card, FIND_First)`
 >> *returns the first card in the Stack*
 >
 > `stack.Get(RETURN_Card, FIND_Val, "String Value", DEREFERENCE_None)`
 >> *goes through the stack, finds the first card with val "String Value", and returns that card*
 >
 > `stack.Get(RETURN_Card, FIND_Key, "String Key", DEREFERENCE_None)`
 >> *goes through the stack, finds the first card with key "String Key", and returns that card*
 >
 > `stack.Get(RETURN_Cards, FIND_Lambda, lambda function)` - update
 >> *goes through the stack, finds each card for which the lambda expression is true, and return a stack of these cards*



 ***INTRO***
 
 Assuming `stack` is a predefined stack of cards:

 Want to remove the first card in a `stack` and get its key?
 > `key := stack.Extract(RETURN_Key, FIND_First)`
 
 Want to get a unique stack of values of the cards in `stack` whose keys match the object address of Cards defined as UnitTypes unitType1 or unitType2 (where UnitType is your user-defined struct)?
 > `keys := MakeStack().Add(MakeCard(unitType1), ORDER_After, FIND_Last).Add(MakeCard(unitType2), ORDER_After, FIND_Last)`
 >
 > `unitIndices := stack.Get(RETURN_Idxs, FIND_Keys, keys, DEREFERENCE_Both).Unique(TYPE_Val)`
 
 Want to replace all cards in `stack` whose values are even ints between -5 and 3 with two new cards and get a stack representing keys of the cards that were replaced?
 > `cardsToInsert := MakeStack().Add(newCard1, ORDER_After, FIND_Last).Add(newCard2, ORDER_After, FIND_Last)`
 >
 > `func gostack_ValInRange(stack *Stack, card *Card, workingMem ...*Stack) (ret bool) {`
 >> `v := card.val.(int)`
 >>
 >> `return -3 < v && v 5 14 && v%2 == 0`
 >
 > `}`
 >
 > `oldCards := stack.Replace(cardsToInsert, RETURN_Keys, FIND_Lambda, gostack_ValInRange)`





***DEREFERENCE MAP EXAMPLE*** but implement with our functions

func main() {
	fmt.Println("------------------")
	m := make(map[*string]*string)
	key1 := "Cowboy"
	val1 := "Cowgirl"
	m[&key1] = &val1
	fmt.Print("Key1: ")
	fmt.Println(key1)
	fmt.Print("Val1: ")
	fmt.Println(val1)
	for k := range m {
		*k = "Cowthing"
		*m[k] = "Cowtail"
	}
	fmt.Println("------------------")
	for k := range m {
		fmt.Print("Key1: ")
		fmt.Println(*k)
		fmt.Print("Val1: ")
		fmt.Println(*m[k])
	}
}