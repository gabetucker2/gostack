<h3>...to Demonstrate Flexibility</h3>

 > `stack.Get(RETURN_Card, POSITION_First)`
 >> *returns the first card in the Stack*
 >
 > `stack.Get(RETURN_Card, POSITION_Val, "String Value", MATCH_Object)`
 >> *goes through the stack, finds the first card with val "String Value", and returns that card*
 >
 > `stack.Get(RETURN_Card, POSITION_Key, "String Key", MATCH_Object)`
 >> *goes through the stack, finds the first card with key "String Key", and returns that card*
 >
 > `stack.Get(RETURN_Cards, POSITION_Lambda, lambda function)` - update
 >> *goes through the stack, finds each card for which the lambda expression is true, and return a stack of these cards*
 >
 > `stack.Get(RETURN_Cards, POSITION_Val, "String Value", MATCH_Object)`
 >> *goes through the stack, finds each card with val "String Value", and returns a Stack of each of those cards*
 >
 > `stack.Get(RETURN_Card, POSITION_Val, stackOfValues, MATCH_Object)`
 >> *goes through the stack, finds the first card with one of the values in stackOfValues, and returns that card*
 >
 > `stack.Get(RETURN_Cards, POSITION_Val, stackOfValues, MATCH_Object)`
 >> *goes through the stack, finds each card with one of the values in stackOfValues, and returns a Stack of each of those cards*
 >
 > `stack.Get(RETURN_Card, POSITION_Val, stackOfValues, MATCH_Reference)`
 >> *goes through the stack, finds the first card with the same memory address as one the values in stackOfValues, and returns that card*
 >
 > `stack.Get(RETURN_Cards, POSITION_Val, stackOfValues, MATCH_Reference)`
 >> *goes through the stack, finds each card with a memory address matching one in stackOfValues, and returns a Stack of each of those cards*


 ***TYPE Example Uses***
 
 > `stack.Add(cardToAdd, ORDER_Before, POSITION_Last)`
 >> *insert a card at the second-to-last index of the stack*
 >
 > `stack.Add(cardToAdd, ORDER_After, POSITION_Last)`
 >> *insert a card at the last index of the stack*

 ***ORDER Example Uses***
 
 > `stack.Add(cardToAdd, ORDER_Before, POSITION_Last)`
 >> *insert a card at the second-to-last index of the stack*
 >
 > `stack.Add(cardToAdd, ORDER_After, POSITION_Last)`
 >> *insert a card at the last index of the stack*

 ***MATCH Example Uses***
 
 > `stack.Get(RETURN_Card, POSITION_Card, cardStructureToFind, MATCH_Object)`
 >> *returns the first card that has the same structure (key and value) as cardStructureToFind*
 >
 > stack.Get(RETURN_Card, POSITION_Card, exactCardToFind, MATCH_Reference)`
 >> *returns the first card that IS exactCardToFind as stored in memoryâ€”not just that's the same structurally*

 ***Stack Example Uses***

 > `stack.size`
 >> *returns the cardinality of the stack's cards (i.e., amount of cards in the stack)*

 ***RETURN Example Uses***
 
 > `stack.Get(RETURN_Card, POSITION_Val, "String Value", MATCH_Object)`
 >> *goes through the stack, finds the first card with val "String Value", and returns that card*
 >
 > `stack.Get(RETURN_Cards, POSITION_Val, "String Value", MATCH_Object)`
 >> *goes through the stack, finds each card with val "String Value", and returns a Stack of each of those cards*
 >
 > `stack.Get(RETURN_Card, POSITION_Val, stackOfValues, MATCH_Object)`
 >> *goes through the stack, finds the first card with one of the values in stackOfValues, and returns that card*
 >
 > `stack.Get(RETURN_Cards, POSITION_Val, stackOfValues, MATCH_Object)`
 >> *goes through the stack, finds each card with one of the values in stackOfValues, and returns a Stack of each of those cards*

 ***POSITION Example Uses***
 
 > `stack.Get(RETURN_Card, POSITION_First)`
 >> *returns the first card in the Stack*
 >
 > `stack.Get(RETURN_Card, POSITION_Val, "String Value", MATCH_Object)`
 >> *goes through the stack, finds the first card with val "String Value", and returns that card*
 >
 > `stack.Get(RETURN_Card, POSITION_Key, "String Key", MATCH_Object)`
 >> *goes through the stack, finds the first card with key "String Key", and returns that card*
 >
 > `stack.Get(RETURN_Cards, POSITION_Lambda, lambda function)` - update
 >> *goes through the stack, finds each card for which the lambda expression is true, and return a stack of these cards*



 ***INTRO***
 
 Assuming `stack` is a predefined stack of cards:

 Want to remove the first card in a `stack` and get its key?
 > `key := stack.Extract(RETURN_Key, POSITION_First)`
 
 Want to get a unique stack of values of the cards in `stack` whose keys match the object address of Cards defined as UnitTypes unitType1 or unitType2 (where UnitType is your user-defined struct)?
 > `keys := MakeStack().Add(MakeCard(unitType1), ORDER_After, POSITION_Last).Add(MakeCard(unitType2), ORDER_After, POSITION_Last)`
 >
 > `unitIndices := stack.Get(RETURN_Idxs, POSITION_Keys, keys, MATCH_Reference).Unique(TYPE_Val)`
 
 Want to replace all cards in `stack` whose values are even ints between -5 and 3 with two new cards and get a stack representing keys of the cards that were replaced?
 > `cardsToInsert := MakeStack().Add(newCard1, ORDER_After, POSITION_Last).Add(newCard2, ORDER_After, POSITION_Last)`
 >
 > `func gostack_ValInRange(stack *Stack, card *Card, workingMemory ...*Stack) (ret bool) {`
 >> `v := card.val.(int)`
 >>
 >> `return -3 < v && v 5 14 && v%2 == 0`
 >
 > `}`
 >
 > `oldCards := stack.Replace(cardsToInsert, RETURN_Keys, POSITION_Lambda, gostack_ValInRange)`
